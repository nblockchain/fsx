#!/usr/bin/env fsharpi

open System
open System.IO
open System.Linq

#load "Infra.fs"
open FSX.Infrastructure

let verbose = false

let PrintUsage () =
    Console.WriteLine("Usage: ./fsx.fsx  [OPTION]... yourscript.fsx")
    Console.WriteLine()
    Console.WriteLine("Options")
    Console.WriteLine("  -c, --compile     Only compile (don't run), if binaries don't exist")
    Console.WriteLine("                    or their timestamp is older than source")
    Console.WriteLine("  -k, --check       Check if it compiles (don't run), without checking previous")
    Console.WriteLine("                    existence or timestamp, and without generating binaries")

let args = Util.FsxArguments()
if (args.Length = 0 || (args.Length = 1 && args.[0] = "--help")) then
    PrintUsage()
    Environment.Exit(1)

type Flag = OnlyCompile | OnlyCheck
type ProvidedCommandLineArguments =
    { Flags: list<Flag>; MaybeScript: Option<FileInfo> }
type ParsedCommandLineArguments =
    { Flags: list<Flag>; Script: FileInfo }

type BinFolder = { Dir: DirectoryInfo; Created: bool }
type ExeTarget = { Exe: FileInfo; BinFolderCreated: bool }
type BuildResult = Failure of BinFolder | Success of ExeTarget

let rec ParseArgsInternal (args: string list) (finalArgs: ProvidedCommandLineArguments): ProvidedCommandLineArguments =
    match args with
    | [] -> finalArgs
    | arg::tail ->
        let maybeFlag: Option<Flag> =
            if (arg = "-c" || arg = "--compile") then
                Some(OnlyCompile)
            else if (arg = "-k" || arg = "--check") then
                Some(OnlyCheck)
            else if (arg.StartsWith("-")) then
                failwith (sprintf "Flag not recognized: %s" arg)
            else
                None

        let newArgs =
            match maybeFlag with
            | None ->
                if not (arg.EndsWith(".fsx")) then
                    failwith (sprintf "Argument not recognized: %s. Only commands, or scripts ending with .fsx allowed" arg)
                else if (finalArgs.MaybeScript.IsSome) then
                    failwith (sprintf "Only one .fsx script allowed")
                else
                    { Flags = finalArgs.Flags; MaybeScript = Some(FileInfo(arg)) }
            | Some(flag) ->
                    { Flags = flag::finalArgs.Flags; MaybeScript = finalArgs.MaybeScript }

        ParseArgsInternal tail newArgs

exception NoScriptProvided

let ParseArgs(args: string list): ParsedCommandLineArguments =
    let parsedArgs = ParseArgsInternal args { Flags = []; MaybeScript = None }
    match parsedArgs.MaybeScript with
    | None -> raise (NoScriptProvided)
    | Some(scriptFileName) -> { Flags = parsedArgs.Flags; Script = scriptFileName }

let LOAD_PREPROCESSOR = "#load \""
let REF_PREPROCESSOR = "#r \""

type PreProcessorAction = Skip | Load of string | Ref of string
type LineAction = Normal | PreProcessorAction of PreProcessorAction
type FsxScript =
    { Original: FileInfo; Backup: FileInfo }
type CompilerInput =
    SourceFile of FileInfo | Script of FsxScript | Ref of string

let GetBinFolderForAScript(script: FileInfo) =
    DirectoryInfo(Path.Combine(script.Directory.FullName, "bin"))

let GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder (orig: FileInfo) (extension: string) =
    let binDir = GetBinFolderForAScript(orig)
    let autogeneratedFileName =
        if (String.IsNullOrEmpty(extension)) then
            orig.Name
        else
            sprintf "%s.%s" orig.Name extension
    let autogeneratedFile = FileInfo(Path.Combine(binDir.FullName, autogeneratedFileName))
    autogeneratedFile,binDir

let BuildFsxScript(script: FileInfo): BuildResult =
    if (script = null) then
        raise(ArgumentNullException("script"))
    if not (script.FullName.EndsWith(".fsx")) then
        invalidArg "script" "The script filename needs to end with .fsx extension"

    let binFolderExistedOriginally = GetBinFolderForAScript(script).Exists

    let readPreprocessorLine(line: string) =
        if (line.StartsWith("#!")) then
            PreProcessorAction.Skip
        else if (line.StartsWith(LOAD_PREPROCESSOR)) then
            let fileToLoad = line.Substring(LOAD_PREPROCESSOR.Length, line.Length - LOAD_PREPROCESSOR.Length - 1)
            PreProcessorAction.Load(fileToLoad)
        else if (line.StartsWith(REF_PREPROCESSOR)) then
            let libToRef = line.Substring(REF_PREPROCESSOR.Length, line.Length - REF_PREPROCESSOR.Length - 1)
            PreProcessorAction.Ref(libToRef)
        else
            failwith (sprintf "Unrecognized preprocessor line: %s" line)

    let readLine (line: string) (origScript: FileInfo): LineAction =
        if (line.StartsWith("#")) then
            LineAction.PreProcessorAction(readPreprocessorLine(line))
        else
            LineAction.Normal

    let rec getBackupFileName(fileToBackup: FileInfo) =
        let backupFile = fileToBackup.FullName + ".bak"
        if (File.Exists(backupFile)) then
            getBackupFileName(FileInfo(backupFile))
        else
            backupFile

    let preprocessScriptContents(origScript: FileInfo): List<CompilerInput> =
        let autogeneratedFile,binFolder = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder origScript String.Empty

        if autogeneratedFile.Exists then
            failwith (sprintf
                          "fsx needs to copy %s to %s for preprocessing work, but the file already exists"
                          origScript.FullName autogeneratedFile.FullName)
        if not (binFolder.Exists) then
            Directory.CreateDirectory(binFolder.FullName) |> ignore
        File.Copy(origScript.FullName, autogeneratedFile.FullName, true)

        let contents = File.ReadAllText(autogeneratedFile.FullName)
        let lines = contents.Split([| Environment.NewLine |], StringSplitOptions.None)

        File.WriteAllText(autogeneratedFile.FullName, String.Empty)

        seq {
            for line in lines do

                let startCommentInFSharp = "//"

                let maybeDep = readLine line origScript
                match maybeDep with
                | LineAction.Normal ->
                    File.AppendAllText(autogeneratedFile.FullName, line + Environment.NewLine)
                | LineAction.PreProcessorAction(action) ->
                    File.AppendAllText(autogeneratedFile.FullName, startCommentInFSharp + line + Environment.NewLine)
                    match action with
                    | PreProcessorAction.Skip -> ()
                    | PreProcessorAction.Load(fileName) ->
                        let file = FileInfo(Path.Combine(origScript.Directory.FullName, fileName))
                        yield CompilerInput.SourceFile(file)
                    | PreProcessorAction.Ref(refName) ->
                        yield CompilerInput.Ref(refName)

            let backupFile = FileInfo(getBackupFileName(origScript))
            File.Copy(origScript.FullName, backupFile.FullName)
            File.Copy(autogeneratedFile.FullName, origScript.FullName, true)
            autogeneratedFile.Delete()
            yield CompilerInput.Script({ Original = origScript; Backup = backupFile})
        } |> List.ofSeq

    let getSourceFiles(flags: seq<CompilerInput>): seq<FileInfo>=
        seq {
            for f in flags do
                match f with
                | CompilerInput.SourceFile(file) -> yield file
                | CompilerInput.Script(script) -> yield script.Original
                | _ -> ()
        }

    let getCompilerReferences(flags: seq<CompilerInput>): seq<string>=
        seq {
            for f in flags do
                match f with
                | CompilerInput.Ref(refName) -> yield sprintf "--reference:%s" refName
                | _ -> ()
        }

    let restoreBackups(compilerInputs: seq<CompilerInput>) =
        for compilerInput in compilerInputs do
            match compilerInput with
            | CompilerInput.Script(script) ->
                // it's sad that File.Move(_,_,bool) overload doesn't exist...
                File.Copy(script.Backup.FullName, script.Original.FullName, true)
                script.Backup.Delete()
            | _ -> ()

    if (verbose) then
        Console.WriteLine("Building {0}", script)

    let binFolder = GetBinFolderForAScript(script)
    let compilerInputs = preprocessScriptContents(script)
    let filesToCompile = getSourceFiles(compilerInputs)
    let exitCode,exeTarget =
        try
            let exeTarget,_ = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder script "exe"
            let sourceFiles = String.Join(" ", filesToCompile)
            let refs = String.Join (" ", getCompilerReferences(compilerInputs))
            let fscompilerflags = (sprintf "%s --target:exe --out:%s %s" refs exeTarget.FullName sourceFiles)
            let processResult = Process.Execute("fsharpc " + fscompilerflags, verbose, (not verbose))
            if not (processResult.ExitCode = 0) then
                Process.PrintToScreen(processResult.Output)
            processResult.ExitCode,exeTarget

        finally
            restoreBackups(compilerInputs)

    let success =
        match exitCode with
        | 0 -> true
        | _ -> false

    if not (success) then
        Console.Error.WriteLine("Build failure")
        BuildResult.Failure({ Dir = binFolder; Created = (not binFolderExistedOriginally) })
    else
        BuildResult.Success({ Exe = exeTarget; BinFolderCreated = (not binFolderExistedOriginally) })

let parsedArgs =
    try
        ParseArgs(args)
    with
    | :? NoScriptProvided ->
        Console.Error.WriteLine("At least one .fsx script is required as input. Use --help for info.")
        Environment.Exit(1)
        failwith "Unreachable"

// FIXME: check dependencies of file too
let GetAlreadyBuiltExecutable(script: FileInfo): Option<FileInfo> =
    let exeTarget,binFolder = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder script "exe"
    if not (binFolder.Exists) then
        None
    else if (binFolder.LastWriteTime < script.LastWriteTime) then
        None
    else if not (exeTarget.Exists) then
        None
    else if (exeTarget.LastWriteTime < script.LastWriteTime) then
        None
    else
        Some(exeTarget)

let RunTheExecutable(exe: FileInfo) =
    let runResult = Process.Execute(sprintf "mono %s" exe.FullName, false, false)
    runResult.ExitCode

let Build(artifacts: bool) =
    let buildResult = BuildFsxScript(parsedArgs.Script)

    match buildResult with
    | Failure(binFolder) ->
        if (binFolder.Created) then
            binFolder.Dir.Delete(true)
        Environment.Exit(1)
        failwith "Unreachable"

    | Success(exeTarget) ->
        if not (artifacts) then
            if (exeTarget.BinFolderCreated) then
                exeTarget.Exe.Directory.Delete(true)
        exeTarget.Exe

// force build, not even check if the .exe is there
if (parsedArgs.Flags.Contains(Flag.OnlyCheck)) then
    Build(false) |> ignore
    Environment.Exit 0

let maybeExe = GetAlreadyBuiltExecutable(parsedArgs.Script)
let theExe =
    match maybeExe with
    | None -> Build(true)
    | Some(alreadyExistingExe) -> alreadyExistingExe

if (parsedArgs.Flags.Contains(Flag.OnlyCompile)) then
    Environment.Exit 0

let exitCodeOfTheRun = RunTheExecutable(theExe)
Environment.Exit exitCodeOfTheRun
